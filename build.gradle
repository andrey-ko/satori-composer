gradle.startParameter.showStacktrace = ShowStacktrace.ALWAYS

apply plugin: 'idea'

group group
version version
buildDir = '.out'

idea {
  project {
    jdkName = '1.8'
    languageLevel = '1.8'
  }
  module {
    inheritOutputDirs = false
    outputDir = file(".out/idea")
    testOutputDir = file(".out/idea-tests")
  }
}

task generateReadme(type: TransformTask) {
  group 'codegen'
  template = file('readme.template.md')
  output = file('readme.md')
  outputs.upToDateWhen { false }
}

tasks.generateReadme.execute()

void transform(Closure closure) {
  def spec = new TransformSpec(project)
  closure.delegate = spec
  closure.resolveStrategy = Closure.DELEGATE_FIRST
  closure()
  Transform.execute(spec, project)
}

allprojects {
  task info() {
    group 'help'
    outputs.upToDateWhen { false }
  }
}

subprojects {
  group rootProject.group
  version rootProject.version

  apply plugin: 'java'
  apply plugin: 'idea'

  sourceCompatibility = 1.8
  targetCompatibility = 1.8

  //tasks.withType(Javadoc).all { enabled = false }

  buildDir = '.out'
  sourceSets.main.java.srcDirs = ['src']
  sourceSets.main.resources.srcDirs = ['res']
  sourceSets.test.java.srcDirs = ['tests/src']
  sourceSets.test.resources.srcDirs = ['tests/res']

  compileJava.options.compilerArgs << "-Xlint:unchecked"
  compileJava.options.compilerArgs << "-Xlint:deprecation"

  idea {
    module {
      inheritOutputDirs = false
      outputDir = file(".out/idea")
      testOutputDir = file(".out/idea-tests")
    }
  }

  repositories {
    mavenCentral()
    jcenter()
    maven {
      url('https://oss.sonatype.org/content/repositories/snapshots/')
    }
  }

  dependencies {
  }

  task createDefaultProjectStructure {
    group 'codegen'
    doLast {
      def groupDir = project.group.replace('.', '/')
      def projDir = project.name.replace('-', '/')
      file("src/$groupDir/$projDir").mkdirs()
      file("res/$groupDir/$projDir").mkdirs()
      file("tests/src/$groupDir/$projDir").mkdirs()
      file("tests/res/$groupDir/$projDir").mkdirs()
      if (!file("build.gradle").exists()) {
        transform {
          template = rootProject.file('build.template.gradle')
          output = file('build.gradle')
        }
      }
    }
  }
}

def publishingProjects = [
  ':composer',
  ':mods',
  ':mods-suite',
  ':libs-async-api',
  ':libs-async-core',
  ':libs-gtfs'
].collect { project(it) }

configure(publishingProjects) {
  apply from: rootProject.file('publishing.gradle')

  afterEvaluate {
    task zipOutRepository(type: Zip) { t ->
      group 'github'
      dependsOn pulishToOutRepo
      def groupId = pulishToOutRepo.publication.groupId
      def artifactId = pulishToOutRepo.publication.artifactId
      def version = pulishToOutRepo.publication.version

      def relativeDir = "${groupId.replace('.', '/')}/${artifactId.replace('.', '/')}/${version}"
      def srcDir = file("${pulishToOutRepo.repository.url}/$relativeDir")

      from(srcDir) {
        into relativeDir
      }
      archiveName "satori-$artifactId v${version}.zip"
      destinationDir buildDir
      doFirst {
        println "zipping $srcDir -> ${outputs.getFiles()*.path.join(',')}"
      }

      rootProject.mergeAllOutRepositories.dependsOn(t)
      outputs.getFiles().each {
        rootProject.mergeAllOutRepositories.from(zipTree(it))
      }

      rootProject.githubPublishRelease.asset(t)
    }
  }
}

task mergeAllOutRepositories(type: Zip) {
  group 'github'

  archiveName "satori-all v${project.version}.zip"
  destinationDir buildDir
}


ext {
  githubRepo = "/satori-com/satori-composer"
  githubUrl = "https://api.github.com/repos${githubRepo}/"
}

if (rootProject.file(".gradle/github.gradle").exists()) {
  apply from: rootProject.file(".gradle/github.gradle")
}

task githubListReleases(type: GitHubListReleasesTask) {
  url = githubUrl
  authToken = githubAuthToken
}

task githubPublishRelease(type: GitHubPublishReleaseTask) {
  url = githubUrl
  authToken = githubAuthToken
  asset mergeAllOutRepositories
}

info {
  doLast {
    println "publishing projects:"
    publishingProjects.each {
      println "  ${it.name}"
    }
  }
}