gradle.startParameter.showStacktrace = ShowStacktrace.ALWAYS

buildscript {
  repositories {
    mavenCentral()
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
    //maven { url file(".repo") }
  }
  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"

    classpath "com.satori:satori-libs-gradle-transform:$scaffoldingVersion"
    classpath "com.satori:satori-libs-gradle-github:$scaffoldingVersion"
    classpath "com.satori:satori-libs-composition-drawer:$scaffoldingVersion"
  }
}

apply plugin: "com.satori.transform"
apply plugin: "com.satori.github"
apply plugin: "com.satori.composition.drawer"

apply plugin: 'idea'

group group
version version
buildDir = '.out'

idea {
  project {
    jdkName = '1.8'
    languageLevel = '1.8'
  }
  module {
    inheritOutputDirs = false
    outputDir = file(".out/idea")
    testOutputDir = file(".out/idea-tests")
  }
}

ext {
  pckg = group
  pckgDir = pckg.replace('.', '/')
  examples = container(Object)
}

task generateCode {
  group "codegen"
}
task classes {
  dependsOn generateCode
  group "build"
}
task build {
  dependsOn classes
  group "build"
}
task publishRelease{
  group 'build'
}

task generateReadme(type: TransformTask) {
  group 'codegen'
  template = file('readme.template.md')
  output = file('readme.md')
  //outputs.upToDateWhen { false }
}
generateCode.dependsOn generateReadme

allprojects {
  task info() {
    group 'help'
    outputs.upToDateWhen { false }
  }
}

subprojects {
  group rootProject.group
  version rootProject.version

  apply plugin: 'java'
  apply plugin: 'idea'

  sourceCompatibility = 1.8
  targetCompatibility = 1.8

  //tasks.withType(Javadoc).all { enabled = false }

  buildDir = '.out'
  sourceSets.main.java.srcDirs = ['src']
  sourceSets.main.resources.srcDirs = ['res']
  sourceSets.test.java.srcDirs = ['tests/src']
  sourceSets.test.resources.srcDirs = ['tests/res']

  compileJava.options.compilerArgs << "-Xlint:unchecked"
  compileJava.options.compilerArgs << "-Xlint:deprecation"

  archivesBaseName = (path - ~/^[^\w]+/).replaceAll(~/[^\w]+/, "-")

  idea {
    module {
      inheritOutputDirs = false
      outputDir = file(".out/idea")
      testOutputDir = file(".out/idea-tests")
    }
  }
  apply plugin: 'kotlin'


  kotlin {
    experimental {
      coroutines 'enable'
    }
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = JavaVersion.VERSION_1_8
    }
  }

  task testPreapare{
    group "verification"
  }
  test.dependsOn testPreapare


  ext {
    // define project base package
    pckg = "${project.parent.pckg}.${name.replaceAll("[^\\w]+", ".")}"
    pckgDir = pckg.replace('.', '/')
  }

  repositories {
    mavenCentral()
    jcenter()
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
    //maven { url file(".repo") }
  }

  dependencies {
  }

  sourceSets.all { sourceSet ->
    def n = sourceSet.name
    n = n != "main" ? n.capitalize() : ""
    def taskName = "generate${n}Code"
    println "defining task: '${project.name}:${taskName}'"
    def t = task "generate${n}Code"() {
      group 'codegen'
    }
    tasks["compile${n}Java"].dependsOn t
    tasks["compile${n}Kotlin"].dependsOn t
  }

  task createDefaultProjectStructure {
    group 'codegen'
    doLast {
      println "creating default project structure for project '${project.name}'..."

      // create directories for all source sets
      sourceSets.forEach { sourceSet ->
        sourceSet.java.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating sources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
        sourceSet.resources.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating resources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
      }

      // generate build.gradle
      if (!file("build.gradle").exists()) {
        println "creating build.gadle: '${file('build.gradle')}'"
        transform {
          template = rootProject.file('build.template.gradle')
          output = file('build.gradle')
        }
      }
    }
  }

  test {
    testLogging {
      events "STARTED", "PASSED", "SKIPPED", "FAILED", "STANDARD_OUT", "STANDARD_ERROR"
    }
  }
}

def publishingProjects = [
  ':composer',
  ':mods',
  ':mods-suite',
  ':libs-async-api',
  ':libs-async-core',
  ':libs-async-kotlin',
  ':libs-gtfs',
  ':libs-composition-drawer',
  ':libs-gradle-utils',
  ':libs-gradle-transform',
  ':libs-gradle-github',
  ':libs-gradle-docker'
].collect { project(it) }

configure(publishingProjects) {
  apply from: rootProject.file('publishing.gradle')

  afterEvaluate {
    task zipOutRepository(type: Zip) { t ->
      group 'github'
      dependsOn pulishToOutRepo
      def groupId = pulishToOutRepo.publication.groupId
      def artifactId = pulishToOutRepo.publication.artifactId
      def version = pulishToOutRepo.publication.version

      def relativeDir = "${groupId.replace('.', '/')}/${artifactId.replace('.', '/')}/${version}"
      def srcDir = file("${pulishToOutRepo.repository.url}/$relativeDir")

      from(srcDir) {
        into relativeDir
      }
      archiveName "$artifactId v${version}.zip"
      destinationDir buildDir
      doFirst {
        println "zipping $srcDir -> ${outputs.files*.path.join(',')}"
      }

      rootProject.mergeAllOutRepositories.dependsOn(t)
      outputs.files.each {
        rootProject.mergeAllOutRepositories.from(zipTree(it))
      }

      rootProject.githubPublishRelease.asset(t)
    }
  }
}

task mergeAllOutRepositories(type: Zip) {
  group 'github'

  archiveName "satori-all v${project.version}.zip"
  destinationDir buildDir
}


ext {
  githubRepo = "/satori-com/satori-composer"
  githubUrl = "https://api.github.com/repos${githubRepo}/"
}

if (rootProject.file(".gradle/github.gradle").exists()) {
  apply from: rootProject.file(".gradle/github.gradle")
}

task githubListReleases(type: GitHubListReleasesTask) {
  url = githubUrl
  if (project.hasProperty('githubAuthToken')) {
    authToken = githubAuthToken
  }
}

task githubPublishRelease(type: GitHubPublishReleaseTask) {
  dependsOn generateCode
  url = githubUrl
  if (project.hasProperty('githubAuthToken')) {
    authToken = githubAuthToken
  }
  asset mergeAllOutRepositories
}

info {
  doLast {
    println "publishing projects:"
    publishingProjects.each {
      println "  ${it.name}"
    }
  }
}
