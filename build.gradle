gradle.startParameter.showStacktrace = ShowStacktrace.ALWAYS

apply plugin: 'idea'

group group
version version
buildDir = '.out'

idea {
  project {
    jdkName = '1.8'
    languageLevel = '1.8'
  }
  module {
    inheritOutputDirs = false
    outputDir = file(".out/idea")
    testOutputDir = file(".out/idea-tests")
  }
}

buildscript {
  repositories {
    mavenCentral()
  }

  dependencies {
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
  }
}

ext {
  pckg = group
  pckgDir = pckg.replace('.', '/')
}

afterEvaluate {
  task generateBigBlueBusImage(type: JavaExec) {
    group 'codegen'

    def cfgPath = project(":mods-examples-big-blue-bus").file("res/com/satori/mods/resources/config.json")
    def imgPath = rootProject.file("docs/files/big-blue-bus-composition.png")

    inputs.file(cfgPath)
    outputs.file(imgPath)

    classpath project(":libs-composition-drawer").sourceSets.main.output
    classpath project(":libs-composition-drawer").configurations.runtime

    main = "${project(":libs-composition-drawer").pckg}.App"
    args "--cfg-path", cfgPath
    args "--img-path", imgPath

    doFirst {
      println "generating composition diagram ...."
      println commandLine.join(" ")
    }
  }

  task generateReadme(type: TransformTask) {
    group 'codegen'
    dependsOn generateBigBlueBusImage
    template = file('readme.template.md')
    output = file('readme.md')
    outputs.upToDateWhen { false }
  }

  tasks.generateReadme.execute()

}

void transform(Closure closure) {
  def spec = new TransformSpec(project)
  closure.delegate = spec
  closure.resolveStrategy = Closure.DELEGATE_FIRST
  closure()
  Transform.execute(spec, project)
}

allprojects {
  task info() {
    group 'help'
    outputs.upToDateWhen { false }
  }
}

subprojects {
  group rootProject.group
  version rootProject.version

  apply plugin: 'java'
  apply plugin: 'idea'

  sourceCompatibility = 1.8
  targetCompatibility = 1.8

  //tasks.withType(Javadoc).all { enabled = false }

  buildDir = '.out'
  sourceSets.main.java.srcDirs = ['src']
  sourceSets.main.resources.srcDirs = ['res']
  sourceSets.test.java.srcDirs = ['tests/src']
  sourceSets.test.resources.srcDirs = ['tests/res']

  compileJava.options.compilerArgs << "-Xlint:unchecked"
  compileJava.options.compilerArgs << "-Xlint:deprecation"

  archivesBaseName = (path - ~/^[^\w]+/).replaceAll(~/[^\w]+/, "-")

  idea {
    module {
      inheritOutputDirs = false
      outputDir = file(".out/idea")
      testOutputDir = file(".out/idea-tests")
    }
  }
  apply plugin: 'kotlin'


  kotlin {
    experimental {
      coroutines 'enable'
    }
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = JavaVersion.VERSION_1_8
    }
  }

  ext {
    // define project base package
    pckg = "${project.parent.pckg}.${name.replaceAll("[^\\w]+", ".")}"
    pckgDir = pckg.replace('.', '/')
  }

  repositories {
    mavenCentral()
    jcenter()
    maven {
      url('https://oss.sonatype.org/content/repositories/snapshots/')
    }
  }

  dependencies {
  }

  sourceSets.all {sourceSet ->
    def n = sourceSet.name
    n = n != "main" ? n.capitalize() : ""
    def taskName = "generate${n}Code"
    println "defining task: '${project.name}:${taskName}'"
    def t = task "generate${n}Code"() {
      group 'codegen'
    }
    tasks["compile${n}Java"].dependsOn t
    tasks["compile${n}Kotlin"].dependsOn t
  }

  task createDefaultProjectStructure {
    group 'codegen'
    doLast {
      println "creating default project structure for project '${project.name}'..."

      // create directories for all source sets
      sourceSets.forEach { sourceSet ->
        sourceSet.java.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating sources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
        sourceSet.resources.srcDirs.forEach {
          def pathToCreate = new File(it, pckgDir)
          println "creating resources path for '${sourceSet.name}': '$pathToCreate'"
          pathToCreate.mkdirs()
        }
      }

      // generate build.gradle
      if (!file("build.gradle").exists()) {
        println "creating build.gadle: '${file('build.gradle')}'"
        transform {
          template = rootProject.file('build.template.gradle')
          output = file('build.gradle')
        }
      }
    }
  }

  test {
    testLogging {
      events "STARTED", "PASSED", "SKIPPED", "FAILED", "STANDARD_OUT", "STANDARD_ERROR"
    }
  }
}

def publishingProjects = [
  ':composer',
  ':mods',
  ':mods-suite',
  ':libs-async-api',
  ':libs-async-core',
  ':libs-async-kotlin',
  ':libs-gtfs',
  ':libs-composition-drawer'
].collect { project(it) }

configure(publishingProjects) {
  apply from: rootProject.file('publishing.gradle')

  afterEvaluate {
    task zipOutRepository(type: Zip) { t ->
      group 'github'
      dependsOn pulishToOutRepo
      def groupId = pulishToOutRepo.publication.groupId
      def artifactId = pulishToOutRepo.publication.artifactId
      def version = pulishToOutRepo.publication.version

      def relativeDir = "${groupId.replace('.', '/')}/${artifactId.replace('.', '/')}/${version}"
      def srcDir = file("${pulishToOutRepo.repository.url}/$relativeDir")

      from(srcDir) {
        into relativeDir
      }
      archiveName "$artifactId v${version}.zip"
      destinationDir buildDir
      doFirst {
        println "zipping $srcDir -> ${outputs.files*.path.join(',')}"
      }

      rootProject.mergeAllOutRepositories.dependsOn(t)
      outputs.files.each {
        rootProject.mergeAllOutRepositories.from(zipTree(it))
      }

      rootProject.githubPublishRelease.asset(t)
    }
  }
}

task mergeAllOutRepositories(type: Zip) {
  group 'github'

  archiveName "satori-all v${project.version}.zip"
  destinationDir buildDir
}


ext {
  githubRepo = "/satori-com/satori-composer"
  githubUrl = "https://api.github.com/repos${githubRepo}/"
}

if (rootProject.file(".gradle/github.gradle").exists()) {
  apply from: rootProject.file(".gradle/github.gradle")
}

task githubListReleases(type: GitHubListReleasesTask) {
  url = githubUrl
  if (project.hasProperty('githubAuthToken')) {
    authToken = githubAuthToken
  }
}

task githubPublishRelease(type: GitHubPublishReleaseTask) {
  url = githubUrl
  if (project.hasProperty('githubAuthToken')) {
    authToken = githubAuthToken
  }
  asset mergeAllOutRepositories
}

info {
  doLast {
    println "publishing projects:"
    publishingProjects.each {
      println "  ${it.name}"
    }
  }
}
